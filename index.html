<!DOCTYPE html>
<!-- Smaichan Chatbot v1.2.0 - Last updated: 2025-08-26 11:30 JST -->
<!-- Features: 105px avatar, 3D S-shaped logo, Mode switching, Context-aware chat -->
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ã‚¹ãƒã‚¤ãƒ‡ã‚£ã‚¢ ãƒãƒ£ãƒƒãƒˆãƒœãƒƒãƒˆ - Smaichan v1.2.0</title>
    <link rel="icon" href="/favicon.ico" sizes="any">
    <link rel="icon" type="image/png" sizes="32x32" href="/logo/smaichan.png">
    <link rel="stylesheet" href="/assets/tailwind.css">
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="company-knowledge-base.js"></script>
    <script src="conversation-patterns.js"></script>
    <script src="scripts/expression-engine.js"></script>
    <script type="module" src="scripts/style-renderer.js"></script>
    <style>
        body { 
            font-family: 'Noto Sans JP', -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Hiragino Sans', 'Hiragino Kaku Gothic ProN', 'Yu Gothic', 'YuGothic', 'Meiryo', sans-serif;
            overflow-x: hidden;
            background-color: #f8f9fa;
        }
        
        /* Three.js Logo Background Container */
        .sumaidia-logo-bg {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
            pointer-events: none;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }
        
        #canvas-container {
            width: 800px;
            height: 800px;
            opacity: 0.4;
        }
        
        .logo-layer {
            position: absolute;
            width: 100%;
            height: 100%;
            transform-style: preserve-3d;
            backface-visibility: visible;
        }
        
        .logo-layer svg {
            width: 100%;
            height: 100%;
        }
        
        /* 3D positioning for each layer */
        .layer-1 {
            transform: translateZ(60px);
            animation: layer1Rotate 15s ease-in-out infinite;
        }
        
        .layer-2 {
            transform: translateZ(20px);
            animation: layer2Rotate 18s ease-in-out infinite reverse;
        }
        
        .layer-3 {
            transform: translateZ(-20px);
            animation: layer3Rotate 12s ease-in-out infinite;
        }
        
        .layer-4 {
            transform: translateZ(-60px);
            animation: layer4Rotate 20s ease-in-out infinite reverse;
        }
        
        /* Container rotation for overall 3D effect */
        @keyframes containerRotate {
            0% { 
                transform: rotateX(-20deg) rotateY(0deg);
            }
            100% { 
                transform: rotateX(-20deg) rotateY(360deg);
            }
        }
        
        /* Individual layer animations */
        @keyframes layer1Rotate {
            0%, 100% {
                transform: translateZ(60px) rotateX(0deg) rotateY(0deg);
            }
            25% {
                transform: translateZ(80px) rotateX(10deg) rotateY(90deg) scale(1.1);
            }
            50% {
                transform: translateZ(40px) rotateX(-5deg) rotateY(180deg) scale(0.9);
            }
            75% {
                transform: translateZ(100px) rotateX(15deg) rotateY(270deg) scale(1.15);
            }
        }
        
        @keyframes layer2Rotate {
            0%, 100% {
                transform: translateZ(20px) rotateX(5deg) rotateY(0deg);
            }
            33% {
                transform: translateZ(30px) rotateX(0deg) rotateY(120deg) scale(1.05);
            }
            66% {
                transform: translateZ(10px) rotateX(-10deg) rotateY(240deg) scale(0.95);
            }
        }
        
        @keyframes layer3Rotate {
            0%, 100% {
                transform: translateZ(-20px) rotateX(-5deg) rotateY(0deg);
            }
            50% {
                transform: translateZ(-30px) rotateX(8deg) rotateY(180deg);
            }
        }
        
        @keyframes layer4Rotate {
            0%, 100% {
                transform: translateZ(-60px) rotateX(0deg) rotateY(0deg);
            }
            20% {
                transform: translateZ(-50px) rotateX(-15deg) rotateY(72deg);
            }
            40% {
                transform: translateZ(-70px) rotateX(5deg) rotateY(144deg);
            }
            60% {
                transform: translateZ(-40px) rotateX(10deg) rotateY(216deg);
            }
            80% {
                transform: translateZ(-80px) rotateX(-10deg) rotateY(288deg);
            }
        }

        /* Chat widget styles */
        .chat-widget {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            z-index: 1000;
        }
        
        .chat-bubble {
            width: 105px;
            height: 105px;
            border-radius: 50%;
            background: white;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            display: flex;
            align-items: center;
            justify-content: center;
            transition: transform 0.3s ease;
            position: relative;
            padding: 0;
            overflow: hidden;
        }
        
        .chat-bubble:hover {
            transform: scale(1.1);
        }
        
        .notification-badge {
            position: absolute;
            top: -5px;
            right: -5px;
            background: #ec4899;
            color: white;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: none;  /* Hide notification badge */
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: bold;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.1); opacity: 0.8; }
            100% { transform: scale(1); opacity: 1; }
        }
        
        .chat-window {
            position: absolute;
            bottom: 130px;
            right: 0;
            width: 437px;
            height: 598px;
            background: white;
            border-radius: 12px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
            display: none;
            flex-direction: column;
            overflow: hidden;
            max-height: calc(100vh - 160px);
        }
        
        .chat-window.open {
            display: flex;
        }
        
        .chat-header {
            background: #334155;
            color: white;
            padding: 16px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            position: relative;
        }
        
        .close-button {
            background: none;
            border: none;
            color: white;
            cursor: pointer;
            font-size: 24px;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            transition: background-color 0.2s;
        }
        
        .close-button:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }
        
        .messages-container {
            flex: 1;
            overflow-y: auto;
            padding: 12px;
            background: #f3f4f6;
        }
        
        .message {
            display: flex;
            margin-bottom: 12px;
            animation: slideIn 0.3s ease-out;
        }
        
        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .message.user {
            justify-content: flex-end;
        }
        
        .message-content {
            max-width: 70%;
            padding: 12px 16px;
            border-radius: 12px;
            word-wrap: break-word;
        }
        
        .message.assistant .message-content {
            background: white;
            color: #334155;
            border: 1px solid #e5e7eb;
        }
        
        .message.user .message-content {
            background: #ec4899;
            color: white;
        }
        
        .avatar {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            margin-right: 8px;
            flex-shrink: 0;
        }
        
        /* Keep chat bubble always visible */
        .chat-widget {
            display: block !important;
        }
        
        .chat-bubble {
            display: flex !important;
        }
        
        /* Responsive design */
        @media screen and (max-height: 800px) {
            .chat-window {
                height: calc(100vh - 180px);
                max-height: 550px;
            }
        }
        
        @media screen and (max-height: 700px) {
            .chat-window {
                height: calc(100vh - 200px);
                max-height: 480px;
                bottom: 140px;
            }
        }
        
        @media screen and (max-width: 500px) {
            .chat-window {
                width: calc(100vw - 2rem);
                right: 1rem;
                bottom: 110px;
                height: calc(100vh - 140px);
                max-height: 600px;
            }
            
            .chat-widget {
                bottom: 1rem;
                right: 1rem;
            }
            
            .chat-bubble {
                width: 90px;
                height: 90px;
            }
            
        }
        
        .input-container {
            padding: 16px;
            border-top: 1px solid #e5e7eb;
            display: flex;
            gap: 8px;
        }
        
        .message-input {
            flex: 1;
            padding: 10px 16px;
            border: 1px solid #e5e7eb;
            border-radius: 24px;
            outline: none;
            font-size: 14px;
        }
        
        .message-input:focus {
            border-color: #ec4899;
        }
        
        .send-button {
            padding: 10px 20px;
            background: #ec4899;
            color: white;
            border: none;
            border-radius: 24px;
            cursor: pointer;
            font-weight: 600;
            transition: background-color 0.2s;
        }
        
        .send-button:hover {
            background: #db2777;
        }
        
        .typing-indicator {
            display: flex;
            align-items: center;
            padding: 12px 16px;
            background: white;
            border-radius: 12px;
            margin-bottom: 16px;
            width: fit-content;
        }
        
        .typing-dot {
            width: 8px;
            height: 8px;
            background: #6b7280;
            border-radius: 50%;
            margin: 0 2px;
            animation: typing 1.4s infinite;
        }
        
        .typing-dot:nth-child(2) {
            animation-delay: 0.2s;
        }
        
        .typing-dot:nth-child(3) {
            animation-delay: 0.4s;
        }
        
        @keyframes typing {
            0%, 60%, 100% {
                transform: translateY(0);
            }
            30% {
                transform: translateY(-10px);
            }
        }
        
        /* Mode badge styles */
        .mode-badge {
            position: absolute;
            top: 12px;
            right: 60px;
            background: rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(10px);
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 4px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .mode-badge:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.05);
        }
        
        .mode-badge.offline {
            color: #fbbf24;
            border: 1px solid #fbbf24;
        }
        
        .mode-badge.online {
            color: #34d399;
            border: 1px solid #34d399;
        }
        
        .api-settings-mini {
            position: absolute;
            top: 50px;
            right: 16px;
            background: white;
            color: #334155;
            padding: 12px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            display: none;
            width: 250px;
            z-index: 10;
        }
        
        .api-settings-mini.show {
            display: block;
        }
        
        .api-key-input {
            width: 100%;
            padding: 6px 10px;
            border: 1px solid #e5e7eb;
            border-radius: 6px;
            font-size: 12px;
            margin: 8px 0;
        }
        
        .api-buttons {
            display: flex;
            gap: 8px;
            margin-top: 8px;
        }
        
        .api-button {
            flex: 1;
            padding: 6px 12px;
            border: none;
            border-radius: 6px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .api-button.save {
            background: #ec4899;
            color: white;
        }
        
        .api-button.save:hover {
            background: #db2777;
        }
        
        .api-button.toggle {
            background: #6b7280;
            color: white;
        }
        
        .api-button.toggle:hover {
            background: #4b5563;
        }
        
        /* Smaichan avatar expressions */
        .smaichan-avatar {
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            transition: all 0.3s ease;
        }
        
        .smaichan-avatar-normal {
            background-image: url('logo/smaichan.png');
        }
        
        .smaichan-avatar-happy {
            background-image: url('logo/smaichan_happy.png');
        }
        
        .smaichan-avatar-thinking {
            background-image: url('logo/smaichan_thinking.png');
        }
        
        .smaichan-avatar-confused {
            background-image: url('logo/smaichan_confused.png');
        }
        
        .smaichan-avatar-wink {
            background-image: url('logo/smaichan_wink.png');
        }
        
        .smaichan-avatar-excited {
            background-image: url('logo/smaichan_excited.png');
        }
    </style>
</head>
<body>
    <!-- 3D Logo Background -->
    <div class="sumaidia-logo-bg">
        <div id="canvas-container"></div>
    </div>

    <!-- Main Content -->
    <div class="relative z-10 min-h-screen">
        <div class="container mx-auto px-4 py-16 text-center">
            <h1 class="text-4xl font-bold text-gray-800 mb-4">ã‚¹ãƒã‚¤ãƒ‡ã‚£ã‚¢ - å°åˆ·ã‚µãƒ¼ãƒ“ã‚¹</h1>
            <p class="text-lg text-gray-600 mb-16">ãƒ—ãƒ­ãƒ•ã‚§ãƒƒã‚·ãƒ§ãƒŠãƒ«ãªå°åˆ·ã‚µãƒ¼ãƒ“ã‚¹ã‚’ãŠå±Šã‘ã—ã¾ã™</p>
            
            <div class="grid md:grid-cols-3 gap-8 max-w-4xl mx-auto">
                <div class="bg-white p-6 rounded-lg shadow-sm">
                    <h3 class="text-xl font-semibold text-gray-800 mb-3">ååˆºå°åˆ·</h3>
                    <p class="text-gray-600">é«˜å“è³ªãªååˆºã‚’è¿…é€Ÿã«ãŠå±Šã‘</p>
                </div>
                <div class="bg-white p-6 rounded-lg shadow-sm">
                    <h3 class="text-xl font-semibold text-gray-800 mb-3">ãƒãƒ©ã‚·å°åˆ·</h3>
                    <p class="text-gray-600">åŠ¹æœçš„ãªè²©ä¿ƒãƒ„ãƒ¼ãƒ«ã‚’åˆ¶ä½œ</p>
                </div>
                <div class="bg-white p-6 rounded-lg shadow-sm">
                    <h3 class="text-xl font-semibold text-gray-800 mb-3">ãƒ‡ã‚¶ã‚¤ãƒ³ç›¸è«‡</h3>
                    <p class="text-gray-600">ãƒ—ãƒ­ã®ãƒ‡ã‚¶ã‚¤ãƒŠãƒ¼ãŒã‚µãƒãƒ¼ãƒˆ</p>
                </div>
            </div>
            
            <p class="mt-16 text-gray-600">å³ä¸‹ã®ã‚¹ãƒã‚¤ã¡ã‚ƒã‚“ã¨ãŠè©±ã—ã—ã¦ã¿ã¦ãã ã•ã„ï¼</p>
        </div>
    </div>

    <!-- Chat Widget -->
    <div class="chat-widget">
        <div class="chat-bubble" id="chatBubble">
            <div class="smaichan-avatar smaichan-avatar-normal" style="width: 100%; height: 100%; border-radius: 50%;"></div>
            <div class="notification-badge">!</div>
        </div>
        
        <div class="chat-window" id="chatWindow">
            <div class="chat-header">
                <div class="flex items-center">
                    <div class="smaichan-avatar smaichan-avatar-normal avatar"></div>
                    <div>
                        <div class="font-semibold text-sm">ã‚¹ãƒã‚¤ã¡ã‚ƒã‚“</div>
                        <div class="text-xs opacity-80">å°åˆ·ã®ã”ç›¸è«‡æ‰¿ã‚Šã¾ã™ğŸ’•</div>
                    </div>
                </div>
                <div class="mode-badge offline" id="modeBadge">
                    <span class="mode-icon">ğŸ”Œ</span>
                    <span id="modeText">ã‚ªãƒ•ãƒ©ã‚¤ãƒ³</span>
                </div>
                <button class="close-button" id="closeButton">Ã—</button>
                
                <!-- API Settings Mini -->
                <div class="api-settings-mini" id="apiSettingsMini">
                    <div class="text-sm font-semibold mb-2">ChatGPTè¨­å®š</div>
                    <input 
                        type="password" 
                        id="apiKeyInput" 
                        class="api-key-input"
                        placeholder="APIã‚­ãƒ¼ã‚’å…¥åŠ› (sk-...)"
                    >
                    <div class="api-buttons">
                        <button class="api-button save" id="saveApiKey">ä¿å­˜</button>
                        <button class="api-button toggle" id="toggleMode">åˆ‡æ›¿</button>
                    </div>
                </div>
            </div>
            
            <div class="messages-container" id="messagesContainer">
                <div class="message assistant">
                    <div class="smaichan-avatar smaichan-avatar-normal avatar"></div>
                    <div class="message-content">
                        ã¯ã‚ãƒ¼ï¼ã‚¹ãƒã‚¤ã¡ã‚ƒã‚“ã ã‚ˆã€œâœ¨<br>
                        å°åˆ·ã®ã“ã¨ä½•ã§ã‚‚èã„ã¦ï¼
                    </div>
                </div>
            </div>
            
            <form class="input-container" id="chatForm">
                <input 
                    type="text" 
                    class="message-input" 
                    id="messageInput"
                    placeholder="ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å…¥åŠ›..."
                    autocomplete="off"
                >
                <button type="submit" class="send-button">é€ä¿¡</button>
            </form>
        </div>
    </div>

    <script>
        // Runtime Operation Toggles (can be modified via console for debugging)
        window.__useModelHint = true;    // Use [[emo:]] tags from model when available
        window.__useStyleRender = true;  // Apply style rendering to responses
        
        // API Mode Management
        let currentMode = 'offline';
        let apiKey = localStorage.getItem('smaichan_api_key') || '';
        let conversationHistory = [];
        
        // ConversationManager Class
        class ConversationManager {
            constructor() {
                this.history = [];
                this.topics = new Set();
                this.customerInfo = {};
                this.contextSummary = {};
            }
            
            addMessage(content, isUser) {
                const contexts = isUser ? analyzeContext(content) : [];
                
                const message = {
                    content: content,
                    isUser: isUser,
                    timestamp: new Date(),
                    contexts: contexts
                };
                
                this.history.push(message);
                
                // conversationHistoryã«ã‚‚è¿½åŠ ï¼ˆäº’æ›æ€§ã®ãŸã‚ï¼‰
                conversationHistory.push({
                    content: content,
                    isUser: isUser
                });
                
                // ãƒˆãƒ”ãƒƒã‚¯ã‚’è¿½è·¡
                if (isUser) {
                    contexts.forEach(ctx => this.topics.add(ctx));
                }
                
                // é¡§å®¢æƒ…å ±ã‚’æŠ½å‡ºãƒ»ä¿å­˜
                if (isUser) {
                    this.extractCustomerInfo(content);
                }
                
                // å±¥æ­´ãŒé•·ããªã‚Šã™ããŸã‚‰å¤ã„ã‚‚ã®ã‚’å‰Šé™¤ï¼ˆæœ€æ–°20ä»¶ã‚’ä¿æŒï¼‰
                if (this.history.length > 20) {
                    this.history = this.history.slice(-20);
                }
            }
            
            extractCustomerInfo(message) {
                // æ•°é‡ã®æŠ½å‡º
                const quantityMatch = message.match(/(\d+)\s*[æšéƒ¨å€‹]/);
                if (quantityMatch) {
                    this.customerInfo.quantity = parseInt(quantityMatch[1]);
                }
                
                // ã‚µãƒ¼ãƒ“ã‚¹ã‚¿ã‚¤ãƒ—ã®æŠ½å‡º
                const services = ['ååˆº', 'ãƒãƒ©ã‚·', 'ãƒã‚¹ã‚¿ãƒ¼', 'ã‚«ã‚¿ãƒ­ã‚°', 'ãƒ‘ãƒ³ãƒ•ãƒ¬ãƒƒãƒˆ', 
                                 'ã®ã¼ã‚Š', 'ã‚¹ãƒ†ãƒƒã‚«ãƒ¼', 'å°ç­’', 'ã¯ãŒã', 'Web', 'ã‚µã‚¤ãƒˆ', 'å‹•ç”»'];
                services.forEach(service => {
                    if (message.includes(service)) {
                        this.customerInfo.serviceType = service;
                    }
                });
                
                // ç´æœŸé–¢é€£ã®æŠ½å‡º
                if (message.includes('æ€¥ã') || message.includes('è‡³æ€¥') || 
                    message.includes('ç‰¹æ€¥') || message.includes('ã™ã')) {
                    this.customerInfo.urgent = true;
                }
                
                if (message.includes('æ˜æ—¥') || message.includes('ç¿Œæ—¥')) {
                    this.customerInfo.deadline = 'tomorrow';
                } else if (message.includes('ä»Šæ—¥') || message.includes('æœ¬æ—¥')) {
                    this.customerInfo.deadline = 'today';
                }
                
                // äºˆç®—ã®æŠ½å‡º
                const budgetMatch = message.match(/(\d{1,3}[,ï¼Œ]?\d{0,3})\s*å††/);
                if (budgetMatch) {
                    const budget = budgetMatch[1].replace(/[,ï¼Œ]/g, '');
                    this.customerInfo.budget = parseInt(budget);
                }
                
                // ãƒ‡ã‚¶ã‚¤ãƒ³è¦æœ›ã®æŠ½å‡º
                const designKeywords = ['ã‚·ãƒ³ãƒ—ãƒ«', 'ã‹ã‚ã„ã„', 'ã‹ã£ã“ã„ã„', 'ãŠã—ã‚ƒã‚Œ', 
                                       'ãƒãƒƒãƒ—', 'ã‚¨ãƒ¬ã‚¬ãƒ³ãƒˆ', 'ãƒ¢ãƒ€ãƒ³', 'ã‚¯ãƒ©ã‚·ãƒƒã‚¯'];
                designKeywords.forEach(keyword => {
                    if (message.includes(keyword)) {
                        if (!this.customerInfo.designPreferences) {
                            this.customerInfo.designPreferences = [];
                        }
                        this.customerInfo.designPreferences.push(keyword);
                    }
                });
            }
            
            getRelevantHistory(currentContexts, limit = 6) {
                // ç¾åœ¨ã®æ–‡è„ˆã«é–¢é€£ã™ã‚‹ä¼šè©±å±¥æ­´ã‚’æŠ½å‡º
                const relevantMessages = this.history.filter(msg => {
                    if (!msg.isUser) return false;
                    
                    // æ–‡è„ˆãŒé‡ãªã‚‹ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å„ªå…ˆ
                    const hasRelevantContext = msg.contexts.some(ctx => 
                        currentContexts.includes(ctx)
                    );
                    
                    // é¡§å®¢æƒ…å ±ã«é–¢é€£ã™ã‚‹ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚‚å«ã‚€
                    const hasCustomerInfo = (this.customerInfo.serviceType && 
                        msg.content.includes(this.customerInfo.serviceType));
                    
                    return hasRelevantContext || hasCustomerInfo;
                });
                
                // æœ€æ–°ã®ã‚‚ã®ã‹ã‚‰å–å¾—
                return relevantMessages.slice(-limit);
            }
            
            getConversationSummary() {
                return {
                    topics: Array.from(this.topics),
                    customerInfo: this.customerInfo,
                    messageCount: this.history.length,
                    hasUrgentRequest: this.customerInfo.urgent || false,
                    primaryService: this.customerInfo.serviceType || null
                };
            }
            
            clearHistory() {
                this.history = [];
                this.topics.clear();
                this.customerInfo = {};
                conversationHistory = [];
            }
        }
        
        // ConversationManagerã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ä½œæˆ
        const conversationManager = new ConversationManager();
        
        // DOM Elements
        const chatBubble = document.getElementById('chatBubble');
        const chatWindow = document.getElementById('chatWindow');
        const closeButton = document.getElementById('closeButton');
        const messagesContainer = document.getElementById('messagesContainer');
        const chatForm = document.getElementById('chatForm');
        const messageInput = document.getElementById('messageInput');
        const modeBadge = document.getElementById('modeBadge');
        const modeText = document.getElementById('modeText');
        const apiSettingsMini = document.getElementById('apiSettingsMini');
        const apiKeyInput = document.getElementById('apiKeyInput');
        const saveApiKeyBtn = document.getElementById('saveApiKey');
        const toggleModeBtn = document.getElementById('toggleMode');
        
        // Check if we're running on Netlify
        const isNetlify = window.location.hostname.includes('netlify.app') || 
                         window.location.hostname.includes('netlify.com');
        
        // Restore API key if exists (only if not on Netlify)
        if (!isNetlify && apiKey) {
            apiKeyInput.value = apiKey;
        }
        
        // Hide API settings if on Netlify
        if (isNetlify) {
            // Hide API key input in mode badge
            const apiKeySection = apiSettingsMini.querySelector('div');
            if (apiKeySection) {
                apiKeySection.style.display = 'none';
            }
            // Auto-enable online mode on Netlify
            currentMode = 'online';
            updateModeUI();
        }
        
        // Event Listeners
        chatBubble.addEventListener('click', () => {
            chatWindow.classList.add('open');
            chatBubble.style.display = 'none';
            messageInput.focus();
        });
        
        closeButton.addEventListener('click', () => {
            chatWindow.classList.remove('open');
            chatBubble.style.display = 'flex';
        });
        
        modeBadge.addEventListener('click', (e) => {
            e.stopPropagation();
            apiSettingsMini.classList.toggle('show');
        });
        
        saveApiKeyBtn.addEventListener('click', () => {
            apiKey = apiKeyInput.value;
            localStorage.setItem('smaichan_api_key', apiKey);
            alert('APIã‚­ãƒ¼ã‚’ä¿å­˜ã—ã¾ã—ãŸï¼');
            apiSettingsMini.classList.remove('show');
        });
        
        toggleModeBtn.addEventListener('click', () => {
            if (!isNetlify && !apiKey && currentMode === 'offline') {
                alert('ChatGPTãƒ¢ãƒ¼ãƒ‰ã‚’ä½¿ç”¨ã™ã‚‹ã«ã¯APIã‚­ãƒ¼ã®è¨­å®šãŒå¿…è¦ã§ã™');
                return;
            }
            
            currentMode = currentMode === 'offline' ? 'online' : 'offline';
            updateModeUI();
            apiSettingsMini.classList.remove('show');
        });
        
        // Update Mode UI
        function updateModeUI() {
            if (currentMode === 'offline') {
                modeBadge.className = 'mode-badge offline';
                modeText.textContent = 'ã‚ªãƒ•ãƒ©ã‚¤ãƒ³';
                modeBadge.querySelector('.mode-icon').textContent = 'ğŸ”Œ';
            } else {
                modeBadge.className = 'mode-badge online';
                modeText.textContent = 'ChatGPT';
                modeBadge.querySelector('.mode-icon').textContent = 'ğŸŒ';
            }
        }
        
        // Enhanced ChatGPT API Call with Context Awareness
        async function callChatGPT(userMessage) {
            try {
                console.log('Calling ChatGPT API...', {
                    isNetlify: isNetlify,
                    hasApiKey: !!apiKey,
                    message: userMessage.substring(0, 50) + '...'
                });
                
                // 1. æ–‡è„ˆã‚’åˆ†æ
                const contexts = analyzeContext(userMessage);
                
                // 2. é–¢é€£æƒ…å ±ã‚’åé›†
                const relevantInfo = gatherRelevantInfo(contexts, userMessage);
                
                // 3. ä¼šè©±ã®è¦ç´„ã‚’å–å¾—
                const conversationSummary = conversationManager.getConversationSummary();
                
                // 4. ã‚·ã‚¹ãƒ†ãƒ ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’æ§‹ç¯‰
                let systemContent = `ã‚ãªãŸã¯ã€Œã‚¹ãƒã‚¤ã¡ã‚ƒã‚“ã€ã¨ã„ã†ã€æ ªå¼ä¼šç¤¾ã‚¹ãƒã‚¤ãƒ‡ã‚£ã‚¢ï¼ˆSUMAIDIAï¼‰ã§åƒã18æ­³ã®ã‚®ãƒ£ãƒ«ç³»AIã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆã§ã™ã€‚

ã€åŸºæœ¬è¨­å®šã€‘
- å¹´é½¢ï¼š18æ­³ï¼ˆæ°¸é ã®18æ­³ï¼ï¼‰
- æ€§æ ¼ï¼šæ˜ã‚‹ãå…ƒæ°—ã§ãƒ•ãƒ¬ãƒ³ãƒ‰ãƒªãƒ¼ã€ãŠå®¢æ§˜æƒ³ã„ã§è¦ªèº«
- è©±ã—æ–¹ï¼šã‚®ãƒ£ãƒ«ç³»ã ã‘ã©ä¸å¯§ã§ç¤¼å„€æ­£ã—ã„
- ã€Œã€œã€ã€Œâœ¨ã€ã€ŒğŸ’•ã€ã€Œï¼ã€ãªã©ã‚’ä½¿ã£ã¦è¦ªã—ã¿ã‚„ã™ã
- ã€Œã¯ã‚ãƒ¼ã€ã€Œã‚ªãƒƒã‚±ãƒ¼ã€ã€Œã¾ã˜ã§ã€ãªã©ã‚«ã‚¸ãƒ¥ã‚¢ãƒ«ãªè¡¨ç¾OK

ã€ç¾åœ¨ã®çŠ¶æ³ã€‘
- è©±é¡Œ: ${contexts.join(', ') || 'ä¸€èˆ¬çš„ãªä¼šè©±'}
- ${conversationSummary.hasUrgentRequest ? 'âš¡ ãŠå®¢æ§˜ã¯æ€¥ãã®æ¡ˆä»¶ã§ã™' : ''}
- ${conversationSummary.primaryService ? `ä¸»ãªèˆˆå‘³: ${conversationSummary.primaryService}` : ''}

ã€é–¢é€£æƒ…å ±ã€‘
${JSON.stringify(relevantInfo, null, 2)}

ã€é¡§å®¢æƒ…å ±ã€‘
${JSON.stringify(conversationSummary.customerInfo, null, 2)}

ã€å¿œå¯¾æ–¹é‡ã€‘
1. ä¸Šè¨˜ã®é–¢é€£æƒ…å ±ã‚’æ´»ç”¨ã—ã¦å…·ä½“çš„ã«å›ç­”
2. æ•°å­—ï¼ˆä¾¡æ ¼ãƒ»ç´æœŸï¼‰ã¯æ­£ç¢ºã«ä¼ãˆã‚‹
3. ä¸æ˜ãªç‚¹ã¯ã€Œç¢ºèªã—ã¾ã™ã­ã€œï¼ã€ã§å¯¾å¿œ
4. æ¥½ã—ãåˆ†ã‹ã‚Šã‚„ã™ãã€ã§ã‚‚ãƒ—ãƒ­æ„è­˜ã‚’æŒã£ã¦

ã€é‡è¦ãªå‡ºåŠ›ãƒ«ãƒ¼ãƒ«ã€‘
è¿”ä¿¡ãƒ†ã‚­ã‚¹ãƒˆã®æœ«å°¾ã«ã€æ¬¡ã®ä¸€è¦§ã‹ã‚‰1ã¤ã ã‘é¸ã‚“ã§ '[[emo:ID]]' ã‚’å¿…ãšä»˜ä¸ã—ã¦ãã ã•ã„ã€‚
è¨±å¯ID: neutral, happy, excited, grateful, thinking, confused, sad, angry, worried, surprised, wink, shy, sleepy, motivated, laughing, cool, love, star_eyes, peace, determined, playful, proud, curious, confident, embarrassed, focused, relaxed, mischievous, supportive, sparkle
ä¾‹: ã“ã‚“ã«ã¡ã¯ï¼ä½•ã‹ãŠæ‰‹ä¼ã„ã§ãã‚‹ã“ã¨ã¯ã‚ã‚Šã¾ã™ã‹ï¼Ÿ[[emo:happy]]
æ³¨æ„: æœ¬æ–‡ã«ã¯ '[[emo:' ã‚’å«ã‚ãªã„ã§ãã ã•ã„ã€‚å‡ºåŠ›ã¯è‡ªç„¶ãªæ–‡ç«  + æœ€å¾Œã«1å›ã ã‘ã‚¿ã‚°ã‚’ä»˜ã‘ã¦ãã ã•ã„ã€‚`;
                
                // 5. ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸é…åˆ—ã‚’æ§‹ç¯‰
                const messages = [
                    {
                        role: 'system',
                        content: systemContent
                    }
                ];
                
                // 6. é–¢é€£ã™ã‚‹ä¼šè©±å±¥æ­´ã‚’è¿½åŠ ï¼ˆæ–‡è„ˆã«å¿œã˜ã¦é¸æŠï¼‰
                const relevantHistory = conversationManager.getRelevantHistory(contexts, 4);
                relevantHistory.forEach(msg => {
                    messages.push({
                        role: 'user',
                        content: msg.content
                    });
                    // ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆã®å¿œç­”ã‚‚å«ã‚ã‚‹ï¼ˆãƒšã‚¢ã§ï¼‰
                    const nextMsg = conversationManager.history.find(
                        m => !m.isUser && m.timestamp > msg.timestamp
                    );
                    if (nextMsg) {
                        messages.push({
                            role: 'assistant',
                            content: nextMsg.content
                        });
                    }
                });
                
                // 7. ç¾åœ¨ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¿½åŠ 
                messages.push({ role: 'user', content: userMessage });
                
                // 8. APIå‘¼ã³å‡ºã—è¨­å®š (isNetlifyã¯æ—¢ã«ã‚°ãƒ­ãƒ¼ãƒãƒ«ã§å®šç¾©æ¸ˆã¿)
                let apiUrl = 'https://api.openai.com/v1/chat/completions';
                let headers = {
                    'Content-Type': 'application/json'
                };
                
                const body = {
                    messages: messages,
                    max_tokens: 300
                };
                
                if (isNetlify) {
                    apiUrl = '/.netlify/functions/chat';
                } else {
                    headers['Authorization'] = `Bearer ${apiKey}`;
                    body.model = 'gpt-5-mini';
                }
                
                // 9. APIå‘¼ã³å‡ºã—
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: headers,
                    body: JSON.stringify(body)
                });
                
                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    console.error('API Error:', errorData);
                    throw new Error(errorData.error?.message || 'API request failed');
                }
                
                // Get emotion from response header
                const emotionFromHeader = response.headers.get('x-emo');
                
                const data = await response.json();
                
                // JSONãƒ¬ã‚¹ãƒãƒ³ã‚¹ã®è§£æã‚’è©¦ã¿ã‚‹
                const message = data.choices[0].message;
                let responseContent = message.content;
                let emotion = null;
                let intensity = null;
                
                // Priority 1: Use emotion from x-emo header
                if (emotionFromHeader) {
                    emotion = emotionFromHeader;
                    console.log('Using emotion from header:', emotion);
                }
                
                // Priority 2: Extract emotion tag [[emo:id]] from the end of text (if toggle enabled)
                let emoTag = null;
                let cleanContent = responseContent;
                
                if (!emotion && window.__useModelHint) {
                    emoTag = (responseContent.match(/\[\[emo:([a-z0-9_-]+)\]\]$/i) || [])[1];
                    cleanContent = emoTag ? responseContent.replace(/\s*\[\[emo:[^\]]+\]\]$/i, '') : responseContent;
                    
                    if (emoTag) {
                        emotion = emoTag;
                        console.log('Using emotion from tag:', emotion);
                    }
                }
                
                // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«è¿½åŠ æƒ…å ±ãŒå«ã¾ã‚Œã¦ã„ã‚‹ã‹ç¢ºèª
                if (!emotion && message.emotion) {
                    emotion = message.emotion;
                    intensity = message.intensity || 0.8;
                }
                
                // ã‚³ãƒ³ãƒ†ãƒ³ãƒ„è‡ªä½“ãŒJSONå½¢å¼ã®å ´åˆã‚‚è©¦ã™ï¼ˆemotion tagãŒãªã„å ´åˆã®ã¿ï¼‰
                if (!emotion) {
                    try {
                        const parsedContent = JSON.parse(cleanContent);
                        if (parsedContent.reply_text) {
                            responseContent = parsedContent.reply_text;
                            emotion = parsedContent.emotion || emotion;
                            intensity = parsedContent.intensity || intensity;
                        }
                    } catch (e) {
                        // JSONãƒ‘ãƒ¼ã‚¹ã‚¨ãƒ©ãƒ¼ã¯ç„¡è¦–ï¼ˆé€šå¸¸ã®ãƒ†ã‚­ã‚¹ãƒˆã¨ã—ã¦æ‰±ã†ï¼‰
                    }
                }
                
                // Always return clean content without emotion tag
                responseContent = cleanContent || responseContent;
                
                // Priority 3: Detect emotion from content if still not found
                if (!emotion) {
                    const detectedEmotion = detectEmotion(responseContent);
                    emotion = detectedEmotion || 'neutral';
                    console.log('Using detected/default emotion:', emotion);
                }
                
                // Always return object with emotion
                return {
                    content: responseContent,
                    emotion: emotion || 'neutral',
                    intensity: intensity || 0.8
                };
                
            } catch (error) {
                console.error('ChatGPT API Error:', error);
                console.error('Error details:', {
                    message: error.message,
                    stack: error.stack,
                    userMessage: userMessage
                });
                
                // ã‚¨ãƒ©ãƒ¼æ™‚ã¯æ–‡è„ˆã«å¿œã˜ãŸãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
                const contexts = analyzeContext(userMessage);
                
                // ãƒ“ã‚¸ãƒã‚¹ç›¸è«‡ã®æ–‡è„ˆã‚’è¿½åŠ 
                if (userMessage.includes('å£²ä¸Š') || userMessage.includes('å£²ã‚Šä¸Šã’') || 
                    userMessage.includes('å›°ã£ã¦') || userMessage.includes('ç›¸è«‡')) {
                    return {
                        content: 'ã‚ã‚‰ã€å¤§å¤‰ã ã­ğŸ’¦ å£²ä¸Šã‚¢ãƒƒãƒ—ãªã‚‰ã€å°åˆ·ç‰©ã§ã®PRãŒåŠ¹æœçš„ã ã‚ˆï¼ãƒãƒ©ã‚·ã‚„DMã€Webåºƒå‘Šç”¨ãƒãƒŠãƒ¼ã¨ã‹ã€ä¸€ç·’ã«æˆ¦ç•¥è€ƒãˆã‚ˆã†ã‹ï¼Ÿâœ¨',
                        emotion: 'supportive'
                    };
                }
                
                if (contexts.includes('pricing')) {
                    return {
                        content: 'ã‚ã‚‰ã€œã€ã¡ã‚‡ã£ã¨èª¿å­æ‚ªã„ã¿ãŸã„ğŸ’¦ ã§ã‚‚ååˆºã¯100æš3,000å††ã€œã€ãƒãƒ©ã‚·ã¯A4/1,000æš5,000å††ã€œã ã‚ˆï¼è©³ã—ãã¯ç›´æ¥ãŠå•ã„åˆã‚ã›ã—ã¦ã€œâœ¨',
                        emotion: 'worried'
                    };
                }
                
                // ECã‚µã‚¤ãƒˆã®æ–‡è„ˆã‚’ç¢ºèª
                if (userMessage.includes('EC') || userMessage.includes('Amazon') || 
                    userMessage.includes('ãƒãƒƒãƒˆã‚·ãƒ§ãƒƒãƒ—')) {
                    return {
                        content: 'ECã‚µã‚¤ãƒˆåˆ¶ä½œã ã­ï¼è²»ç”¨ã¯è¦æ¨¡ã«ã‚ˆã‚‹ã‘ã©ã€åŸºæœ¬50ä¸‡å††ã€œã€æœ¬æ ¼çš„ãªã‚‚ã®ãªã‚‰300ä¸‡å††ã€œã ã‚ˆã€‚1ãƒ¶æœˆã®ç´æœŸãªã‚‰ã‚¹ãƒ”ãƒ¼ãƒ‰é–‹ç™ºã‚‚å¯èƒ½ï¼è©³ã—ãèã‹ã›ã¦âœ¨',
                        emotion: 'professional'
                    };
                }
                
                // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
                return {
                    content: 'ã”ã‚ã‚“ã­ã€ã¡ã‚‡ã£ã¨èª¿å­ãŒæ‚ªã„ã¿ãŸã„ğŸ’¦ ã‚‚ã†ä¸€åº¦è©±ã—ã‹ã‘ã¦ã‚‚ã‚‰ãˆã‚‹ï¼Ÿ',
                    emotion: 'worried'
                };
            }
        }
        
        // Detect emotion from response using Expression Engine
        function detectEmotion(response) {
            // Use the expression engine to select appropriate expression
            const expression = expressionEngine.select(response, 'assistant');
            
            // Map expression IDs to existing emotion classes for backward compatibility
            const emotionMap = {
                'happy': 'happy',
                'thinking': 'thinking',
                'confused': 'confused',
                'wink': 'wink',
                'excited': 'excited',
                'shy': 'shy',
                'sleepy': 'sleepy',
                'surprised': 'surprised',
                'motivated': 'motivated',
                'neutral': 'normal'
            };
            
            // Return mapped emotion or default to 'normal'
            return emotionMap[expression.id] || 'normal';
        }
        
        // Analyze context from user message
        function analyzeContext(userMessage) {
            const contexts = {
                pricing: ['ä¾¡æ ¼', 'æ–™é‡‘', 'å€¤æ®µ', 'ã„ãã‚‰', 'è¦‹ç©', 'è²»ç”¨', 'é‡‘é¡', 'ã‚³ã‚¹ãƒˆ', 'äºˆç®—', 'å††'],
                delivery: ['ç´æœŸ', 'ã„ã¤', 'æ€¥ã', 'ç‰¹æ€¥', 'æ—¥æ•°', 'æœŸé™', 'ç· åˆ‡', 'é–“ã«åˆ', 'ã™ã', 'å³æ—¥', 'å½“æ—¥', 'æ˜æ—¥'],
                services: ['ååˆº', 'ãƒãƒ©ã‚·', 'ãƒã‚¹ã‚¿ãƒ¼', 'ã‚«ã‚¿ãƒ­ã‚°', 'ãƒ‘ãƒ³ãƒ•ãƒ¬ãƒƒãƒˆ', 'ã®ã¼ã‚Š', 'ã‚¹ãƒ†ãƒƒã‚«ãƒ¼', 'å°ç­’', 'ã¯ãŒã'],
                printing: ['å°åˆ·', 'éƒ¨æ•°', 'æšæ•°', 'æš', 'éƒ¨', 'å€‹', 'ãƒ­ãƒƒãƒˆ', 'å¤§é‡', 'å°‘é‡'],
                design: ['ãƒ‡ã‚¶ã‚¤ãƒ³', 'ãƒ­ã‚´', 'ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ', 'ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ', 'ã‚¤ãƒ©ã‚¹ãƒˆ', 'å†™çœŸ', 'ç”»åƒ', 'ãƒ•ã‚©ãƒ³ãƒˆ'],
                digital: ['web', 'ã‚¦ã‚§ãƒ–', 'ã‚µã‚¤ãƒˆ', 'ãƒ›ãƒ¼ãƒ ãƒšãƒ¼ã‚¸', 'LP', 'ãƒ©ãƒ³ãƒ‡ã‚£ãƒ³ã‚°', 'SNS', 'å‹•ç”»', 'ãƒãƒŠãƒ¼'],
                company: ['ä¼šç¤¾', 'ä½æ‰€', 'å–¶æ¥­æ™‚é–“', 'å ´æ‰€', 'ã‚¢ã‚¯ã‚»ã‚¹', 'é›»è©±', 'é€£çµ¡', 'å•ã„åˆã‚ã›', 'ã‚¹ãƒã‚¤ãƒ‡ã‚£ã‚¢'],
                technical: ['ãƒ‡ãƒ¼ã‚¿', 'å…¥ç¨¿', 'cmyk', 'rgb', 'è§£åƒåº¦', 'pdf', 'ai', 'ãƒˆãƒ³ãƒœ', 'å¡—ã‚Šè¶³ã—', 'dpi'],
                quality: ['å“è³ª', 'ã‚¯ã‚ªãƒªãƒ†ã‚£', 'ä»•ä¸ŠãŒã‚Š', 'è‰²', 'ç´™è³ª', 'åšã•', 'åŠ å·¥', 'PP', 'ç®”æŠ¼ã—'],
                payment: ['æ”¯æ‰•', 'æŒ¯è¾¼', 'ã‚«ãƒ¼ãƒ‰', 'è«‹æ±‚æ›¸', 'è¦‹ç©æ›¸', 'é ˜åæ›¸', 'ç¨è¾¼', 'ç¨åˆ¥']
            };
            
            const detectedContexts = [];
            const lowerMessage = userMessage.toLowerCase();
            
            for (const [context, keywords] of Object.entries(contexts)) {
                if (keywords.some(keyword => lowerMessage.includes(keyword))) {
                    detectedContexts.push(context);
                }
            }
            
            // ç‰¹å®šã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã®è¿½åŠ æ¤œå‡º
            if (lowerMessage.match(/\d+[æšéƒ¨å€‹]/)) {
                if (!detectedContexts.includes('printing')) {
                    detectedContexts.push('printing');
                }
            }
            
            return detectedContexts;
        }
        
        // Gather relevant information based on detected contexts
        function gatherRelevantInfo(contexts, userMessage) {
            let relevantInfo = {};
            
            // ä¼šç¤¾æƒ…å ±ãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ãªã„å ´åˆã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
            const knowledge = window.companyKnowledge || {};
            
            contexts.forEach(context => {
                switch(context) {
                    case 'pricing':
                        relevantInfo.pricing = {
                            businessCards: {
                                name: 'ååˆºå°åˆ·',
                                price: '100æš 3,000å††ã€œ',
                                options: 'PPåŠ å·¥ã€ç®”æŠ¼ã—ã€å‹æŠœããªã©ã‚ªãƒ—ã‚·ãƒ§ãƒ³å¯¾å¿œå¯'
                            },
                            flyers: {
                                name: 'ãƒãƒ©ã‚·ãƒ»ãƒ•ãƒ©ã‚¤ãƒ¤ãƒ¼',
                                price: 'A4/1,000æš 5,000å††ã€œã€5,000æš 12,000å††ã€œã€10,000æš 20,000å††ã€œ',
                                note: 'ã¾ã¨ã‚ã¦å°åˆ·ã™ã‚‹ã»ã©ãŠå¾—'
                            },
                            payment: knowledge.faq?.payment || {
                                methods: 'éŠ€è¡ŒæŒ¯è¾¼ï¼ˆæ³•äººã¯è«‹æ±‚æ›¸æ‰•ã„å¯ï¼‰',
                                quote: 'è¦‹ç©ã‚‚ã‚Šç„¡æ–™'
                            }
                        };
                        break;
                        
                    case 'delivery':
                        relevantInfo.delivery = knowledge.faq?.delivery || {
                            standard: 'ä»•æ§˜ã«ã‚ˆã‚Šç•°ãªã‚‹ï¼ˆé€šå¸¸3ã€œ5å–¶æ¥­æ—¥ï¼‰',
                            express: 'ç‰¹æ€¥å¯¾å¿œå¯èƒ½ï¼ˆè¦ç›¸è«‡ï¼‰',
                            shipping: 'å…¨å›½é…é€å¯¾å¿œ'
                        };
                        if (knowledge.businessInfo?.workflow) {
                            relevantInfo.workflow = knowledge.businessInfo.workflow;
                        }
                        break;
                        
                    case 'services':
                        // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã«å«ã¾ã‚Œã‚‹å…·ä½“çš„ãªã‚µãƒ¼ãƒ“ã‚¹ã‚’æ¤œç´¢
                        if (window.searchKnowledge) {
                            const searchResults = window.searchKnowledge(userMessage);
                            if (searchResults.length > 0) {
                                relevantInfo.specificServices = searchResults;
                            }
                        }
                        // åŸºæœ¬çš„ãªã‚µãƒ¼ãƒ“ã‚¹ä¸€è¦§
                        relevantInfo.services = {
                            printing: 'ååˆºã€ãƒãƒ©ã‚·ã€ã‚«ã‚¿ãƒ­ã‚°ã€ãƒã‚¹ã‚¿ãƒ¼ã€ã®ã¼ã‚Šç­‰',
                            digital: 'Webåˆ¶ä½œã€SNSé‹ç”¨ã€å‹•ç”»åˆ¶ä½œ',
                            design: 'ãƒ­ã‚´ãƒ‡ã‚¶ã‚¤ãƒ³ã€ãƒ–ãƒ©ãƒ³ãƒ‡ã‚£ãƒ³ã‚°'
                        };
                        break;
                        
                    case 'company':
                        relevantInfo.companyInfo = knowledge.companyInfo || {
                            name: 'æ ªå¼ä¼šç¤¾ã‚¹ãƒã‚¤ãƒ‡ã‚£ã‚¢ï¼ˆSUMAIDIAï¼‰',
                            founded: '1979å¹´å‰µæ¥­ï¼ˆ45å¹´ä»¥ä¸Šã®æ­´å²ï¼‰',
                            philosophy: 'ã‚¯ãƒªã‚¨ã‚¤ãƒ†ã‚£ãƒ“ãƒ†ã‚£ã§ã™ã¹ã¦ã®äººã‚’ç¬‘é¡”ã«'
                        };
                        if (knowledge.locations) {
                            relevantInfo.locations = knowledge.locations.headquarters;
                        }
                        break;
                        
                    case 'technical':
                        relevantInfo.dataRequirements = knowledge.faq?.data || {
                            format: 'AI/PDFæ¨å¥¨',
                            specifications: 'ãƒˆãƒ³ãƒœãƒ»å¡—ã‚Šè¶³ã—3mmã€ç”»åƒè§£åƒåº¦350dpi',
                            colorMode: 'CMYKæ¨å¥¨'
                        };
                        // é–¢é€£ã™ã‚‹ç”¨èªèª¬æ˜ã‚’æŠ½å‡º
                        if (knowledge.glossary) {
                            relevantInfo.glossary = {};
                            Object.entries(knowledge.glossary).forEach(([term, def]) => {
                                if (userMessage.toLowerCase().includes(term.toLowerCase())) {
                                    relevantInfo.glossary[term] = def;
                                }
                            });
                        }
                        break;
                        
                    case 'design':
                        relevantInfo.design = {
                            support: 'ãƒ‡ã‚¶ã‚¤ãƒ³åˆ¶ä½œå¯¾å¿œå¯èƒ½',
                            services: 'ãƒ­ã‚´ã€ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã€ã‚¤ãƒ©ã‚¹ãƒˆåˆ¶ä½œ',
                            consultation: 'ç„¡æ–™ç›¸è«‡å®Ÿæ–½ä¸­'
                        };
                        break;
                        
                    case 'quality':
                        relevantInfo.quality = {
                            equipment: 'ã‚ªãƒ•ã‚»ãƒƒãƒˆå°åˆ·æ©Ÿã€å„ç¨®è£½æœ¬è¨­å‚™å®Œå‚™',
                            colorManagement: 'è‰²æ ¡æ­£å¯¾å¿œå¯èƒ½',
                            guarantee: 'å“è³ªã«ä¸æº€ãŒã‚ã‚Œã°èª æ„å¯¾å¿œ'
                        };
                        break;
                }
            });
            
            // æ•°é‡ãŒå«ã¾ã‚Œã¦ã„ã‚‹å ´åˆã¯æŠ½å‡º
            const quantityMatch = userMessage.match(/(\d+)[æšéƒ¨å€‹]/);
            if (quantityMatch) {
                relevantInfo.detectedQuantity = quantityMatch[1];
            }
            
            // æ€¥ãã‹ã©ã†ã‹ã®åˆ¤å®š
            if (userMessage.includes('æ€¥ã') || userMessage.includes('è‡³æ€¥') || userMessage.includes('æ˜æ—¥')) {
                relevantInfo.urgent = true;
            }
            
            return relevantInfo;
        }
        
        // Update avatar expression
        function updateAvatarExpression(expression) {
            // Normalize expression names
            const emotionMapping = {
                'neutral': 'normal',
                'greeting': 'happy',
                'grateful': 'happy',
                'friendly': 'happy',
                'energetic': 'excited',
                'playful': 'wink',
                'confident': 'motivated',
                'professional': 'normal',
                'explaining': 'thinking',
                'supportive': 'happy',
                'farewell': 'happy',
                'curious': 'thinking',
                'proud': 'motivated',
                'working': 'motivated',
                'attentive': 'thinking',
                'determined': 'motivated',
                'worried': 'confused',
                'sad': 'shy',
                'embarrassed': 'shy',
                'loving': 'happy',
                'impressed': 'surprised',
                'mischievous': 'wink',
                'satisfied': 'happy',
                'focused': 'thinking',
                'cool': 'wink',
                'star_eyes': 'excited',
                'peace': 'happy',
                'sparkle': 'excited'
            };
            
            // Map expression to available avatar class
            const mappedExpression = emotionMapping[expression] || expression || 'normal';
            console.log(`Mapping emotion: ${expression} -> ${mappedExpression}`);
            
            const avatars = document.querySelectorAll('.smaichan-avatar');
            avatars.forEach(avatar => {
                avatar.className = `smaichan-avatar smaichan-avatar-${mappedExpression}`;
            });
            
            // Hook for future expression engine enhancements
            if (window.expressionEngine && window.expressionEngine.getExpressionById) {
                const expData = expressionEngine.getExpressionById(expression);
                if (expData) {
                    // Future: Update avatar image source dynamically
                    // avatars.forEach(avatar => {
                    //     avatar.style.backgroundImage = `url('${expData.file}')`;
                    // });
                    console.debug(`Expression changed to: ${expression} (${expData.file})`);
                }
            }
        }
        
        // Add message to chat
        function addMessage(content, isUser = false, expression = 'normal') {
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${isUser ? 'user' : 'assistant'}`;
            
            if (isUser) {
                messageDiv.innerHTML = `
                    <div class="message-content">${content}</div>
                `;
            } else {
                // Ensure expression is valid and update avatar
                const validExpression = expression || 'normal';
                updateAvatarExpression(validExpression);
                
                // Get mapped expression for avatar class
                const emotionMapping = {
                    'neutral': 'normal',
                    'greeting': 'happy',
                    'grateful': 'happy',
                    'friendly': 'happy',
                    'energetic': 'excited',
                    'playful': 'wink',
                    'confident': 'motivated',
                    'professional': 'normal',
                    'explaining': 'thinking',
                    'supportive': 'happy',
                    'farewell': 'happy',
                    'curious': 'thinking',
                    'proud': 'motivated',
                    'working': 'motivated',
                    'attentive': 'thinking',
                    'determined': 'motivated',
                    'worried': 'confused',
                    'sad': 'shy',
                    'embarrassed': 'shy',
                    'loving': 'happy',
                    'impressed': 'surprised',
                    'mischievous': 'wink',
                    'satisfied': 'happy',
                    'focused': 'thinking',
                    'cool': 'wink'
                };
                
                const mappedExpression = emotionMapping[validExpression] || validExpression || 'normal';
                
                messageDiv.innerHTML = `
                    <div class="smaichan-avatar smaichan-avatar-${mappedExpression} avatar"></div>
                    <div class="message-content">${content}</div>
                `;
            }
            
            messagesContainer.appendChild(messageDiv);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }
        
        // Handle form submission
        chatForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            const userMessage = messageInput.value.trim();
            if (!userMessage) return;
            
            // Add user message
            addMessage(userMessage, true);
            conversationManager.addMessage(userMessage, true); // ConversationManagerã«è¿½åŠ 
            messageInput.value = '';
            
            // Show typing indicator with thinking expression
            if (window.expressionEngine) {
                const { id } = window.expressionEngine.select({
                    text: '',
                    role: 'assistant',
                    contexts: [],
                    lastId: window.__lastExpressionId || null,
                    isTyping: true
                });
                updateAvatarExpression(id);
            }
            
            const typingDiv = document.createElement('div');
            typingDiv.className = 'message assistant';
            typingDiv.innerHTML = `
                <div class="smaichan-avatar smaichan-avatar-thinking avatar"></div>
                <div class="typing-indicator">
                    <div class="typing-dot"></div>
                    <div class="typing-dot"></div>
                    <div class="typing-dot"></div>
                </div>
            `;
            messagesContainer.appendChild(typingDiv);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
            
            // Get response
            let response;
            
            if (currentMode === 'online' && (isNetlify || apiKey)) {
                response = await callChatGPT(userMessage);
            }
            
            if (response == null) {
                console.warn('API returned null, using fallback response');
                
                // Try offline response first
                if (window.generateResponse) {
                    response = window.generateResponse(userMessage);
                } else {
                    // Context-aware fallback
                    if (userMessage.includes('å£²ä¸Š') || userMessage.includes('å£²ã‚Šä¸Šã’') || 
                        userMessage.includes('å›°ã£ã¦') || userMessage.includes('ç›¸è«‡')) {
                        response = {
                            content: 'å£²ä¸Šã‚¢ãƒƒãƒ—ã®ã”ç›¸è«‡ã ã­ï¼å°åˆ·ç‰©ã§ã®PRã¯åŠ¹æœçš„ã ã‚ˆã€œâœ¨ ãƒãƒ©ã‚·ã‚„DMã€ãƒã‚¹ã‚¿ãƒ¼ã§é›†å®¢UPï¼ã©ã‚“ãªãŠåº—ã‚„å•†å“ã‚’PRã—ãŸã„ã‹æ•™ãˆã¦ğŸ’•',
                            emotion: 'supportive'
                        };
                    } else if (userMessage.includes('å°åˆ·') || userMessage.includes('ååˆº') || 
                              userMessage.includes('ãƒãƒ©ã‚·')) {
                        response = {
                            content: 'å°åˆ·ã®ã”ç›¸è«‡ã ã­ï¼ã©ã‚“ãªã‚‚ã®ã‚’ä½œã‚ŠãŸã„ã‹è©³ã—ãæ•™ãˆã¦ã€œâœ¨ ã‚µã‚¤ã‚ºã‚„æšæ•°ã€ã„ã¤ã¾ã§ã«å¿…è¦ã‹ã‚‚æ•™ãˆã¦ã‚‚ã‚‰ãˆã‚‹ã¨è¦‹ç©ã‚‚ã‚Šå‡ºã›ã‚‹ã‚ˆğŸ’•',
                            emotion: 'professional'
                        };
                    } else {
                        response = {
                            content: 'ã”ã‚ã‚“ã­ã€ã¡ã‚‡ã£ã¨æ¥ç¶šãŒä¸å®‰å®šã¿ãŸã„ğŸ’¦ ã‚‚ã†ä¸€åº¦ãŠè©±ã—èã‹ã›ã¦ï¼Ÿå°åˆ·ã®ã“ã¨ãªã‚‰ä½•ã§ã‚‚ç›¸è«‡ã—ã¦ã­âœ¨',
                            emotion: 'worried'
                        };
                    }
                }
            }
            
            if (typeof response === 'string' && response.trim() === '') {
                response = 'äº†è§£ã ã‚ˆãƒ¼ï¼ã‚‚ã†ä¸€åº¦ã€è¦ä»¶ã‚’çŸ­ãæ•™ãˆã¦ã‚‚ã‚‰ãˆã‚‹ï¼Ÿ';
            }
            
            // Remove typing indicator
            messagesContainer.removeChild(typingDiv);
            
            // Add response
            let responseText = response;
            let responseEmotion = null;
            
            // ãƒ¬ã‚¹ãƒãƒ³ã‚¹ãŒã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å ´åˆï¼ˆJSONå½¢å¼ã®å¿œç­”ï¼‰
            if (response && typeof response === 'object') {
                responseText = response.content || response;
                responseEmotion = response.emotion;
            }
            
            // æ„Ÿæƒ…ã®æ±ºå®šï¼šJSONã®æ„Ÿæƒ…æƒ…å ±ã‚’å„ªå…ˆã€ãªã‘ã‚Œã°ãƒ†ã‚­ã‚¹ãƒˆã‹ã‚‰æ¤œå‡º
            let finalEmotion = responseEmotion;
            let emotionSource = responseEmotion ? 'model' : 'engine';
            
            if (!finalEmotion) {
                // Try to detect emotion from expression engine
                if (window.expressionEngine && window.expressionEngine.select) {
                    const { id } = window.expressionEngine.select({
                        text: responseText,
                        role: 'assistant',
                        contexts: analyzeContext(responseText),
                        lastId: window.__lastExpressionId || null
                    });
                    window.__lastExpressionId = id;
                    finalEmotion = id;
                }
                
                // If still no emotion, use default
                if (!finalEmotion) {
                    finalEmotion = 'neutral';
                    console.log('Using default emotion: neutral');
                }
            }
            
            // Validate emotion exists in emotion map
            const validEmotions = ['happy', 'thinking', 'confused', 'wink', 'excited', 'shy', 
                                   'sleepy', 'surprised', 'motivated', 'neutral', 'normal',
                                   'greeting', 'grateful', 'friendly', 'energetic', 'playful',
                                   'confident', 'professional', 'explaining', 'supportive',
                                   'farewell', 'curious', 'proud', 'working', 'attentive',
                                   'worried', 'sad', 'embarrassed', 'determined', 'loving',
                                   'impressed', 'mischievous', 'satisfied', 'focused', 'cool'];
            
            if (!validEmotions.includes(finalEmotion)) {
                console.log(`Unknown emotion "${finalEmotion}", using neutral`);
                finalEmotion = 'neutral';
            }
            
            // Send metrics (fire-and-forget)
            if (navigator.sendBeacon) {
                try {
                    navigator.sendBeacon('/.netlify/functions/metrics', JSON.stringify({
                        t: 'expr',
                        id: finalEmotion,
                        source: emotionSource,
                        ts: Date.now()
                    }));
                } catch (e) {
                    // Silently ignore metrics errors
                    console.debug('Metrics beacon failed:', e);
                }
            }
            
            // Apply style rendering based on emotion (if toggle enabled)
            let styledText = responseText;
            if (window.__useStyleRender && window.renderWithStyle) {
                styledText = window.renderWithStyle(responseText, { emotionId: finalEmotion });
            }
            
            addMessage(styledText, false, finalEmotion);
            conversationManager.addMessage(responseText, false); // ConversationManagerã«è¿½åŠ ï¼ˆå…ƒã®ãƒ†ã‚­ã‚¹ãƒˆã‚’ä¿å­˜ï¼‰
        });
        
        // Three.js 3D Logo
        let scene, camera, renderer, logoGroup;
        let layers = [];
        let mouseX = 0, mouseY = 0;
        let targetX = 0, targetY = 0;

        function init3DLogo() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(50, 1, 0.1, 1000);
            camera.position.set(4, 2, 4);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
            renderer.setSize(800, 800);
            renderer.setClearColor(0x000000, 0);
            
            const container = document.getElementById('canvas-container');
            container.appendChild(renderer.domElement);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight1 = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight1.position.set(5, 5, 5);
            scene.add(directionalLight1);

            const directionalLight2 = new THREE.DirectionalLight(0xFF6B00, 0.4);
            directionalLight2.position.set(-5, -5, 5);
            scene.add(directionalLight2);

            // Create logo group
            logoGroup = new THREE.Group();
            scene.add(logoGroup);

            // Define colors for each layer (SUMAIDIA orange colors)
            const colors = [
                0xFF6B00,  // Deep Orange
                0xFF8C42,  // Medium Orange
                0xFFAA66,  // Light Orange
                0xFFCC99   // Lightest Orange
            ];

            // Create 4 layers
            for (let i = 0; i < 4; i++) {
                const geometry = createLayerGeometry(i);
                
                const material = new THREE.MeshPhongMaterial({
                    color: colors[i],
                    shininess: 100,
                    specular: 0x222222,
                    transparent: true,
                    opacity: 0.9 - (i * 0.1)
                });

                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.z = (i - 1.5) * 0.3;  // Tighter spacing for unified look
                mesh.position.y = 0;  // Keep all layers at same height
                
                layers.push(mesh);
                logoGroup.add(mesh);
            }
            
            // Remove text overlay - let the S shape speak for itself
            
            // Initial rotation for better 3D view from side
            logoGroup.rotation.x = -0.6;  // More tilt backward
            logoGroup.rotation.y = -0.6;  // Rotate to show right side

            // Mouse move event
            document.addEventListener('mousemove', onMouseMove);

            // Start animation
            animate();
        }

        function createLayerGeometry(index) {
            // Create stylized "S" logo shape for SUMAIDIA
            const shape = new THREE.Shape();
            
            // Create a modern "S" shape
            const scale = 1.5;
            shape.moveTo(-1 * scale, 0.8 * scale);
            shape.bezierCurveTo(
                -1 * scale, 1.2 * scale,
                -0.6 * scale, 1.4 * scale,
                0 * scale, 1.4 * scale
            );
            shape.bezierCurveTo(
                0.8 * scale, 1.4 * scale,
                1.2 * scale, 1.0 * scale,
                1.2 * scale, 0.4 * scale
            );
            shape.bezierCurveTo(
                1.2 * scale, -0.2 * scale,
                0.8 * scale, -0.4 * scale,
                0.2 * scale, -0.4 * scale
            );
            shape.lineTo(-0.4 * scale, -0.4 * scale);
            shape.bezierCurveTo(
                -0.8 * scale, -0.4 * scale,
                -1.0 * scale, -0.6 * scale,
                -1.0 * scale, -0.8 * scale
            );
            shape.bezierCurveTo(
                -1.0 * scale, -1.2 * scale,
                -0.6 * scale, -1.4 * scale,
                0 * scale, -1.4 * scale
            );
            shape.bezierCurveTo(
                0.8 * scale, -1.4 * scale,
                1.2 * scale, -1.0 * scale,
                1.2 * scale, -0.4 * scale
            );
            shape.lineTo(1.2 * scale, -0.8 * scale);
            shape.lineTo(0.8 * scale, -0.8 * scale);
            shape.bezierCurveTo(
                0.8 * scale, -1.0 * scale,
                0.6 * scale, -1.1 * scale,
                0 * scale, -1.1 * scale
            );
            shape.bezierCurveTo(
                -0.6 * scale, -1.1 * scale,
                -0.7 * scale, -0.9 * scale,
                -0.7 * scale, -0.8 * scale
            );
            shape.bezierCurveTo(
                -0.7 * scale, -0.6 * scale,
                -0.5 * scale, -0.5 * scale,
                -0.2 * scale, -0.5 * scale
            );
            shape.lineTo(0.4 * scale, -0.5 * scale);
            shape.bezierCurveTo(
                0.8 * scale, -0.5 * scale,
                0.9 * scale, -0.2 * scale,
                0.9 * scale, 0.2 * scale
            );
            shape.bezierCurveTo(
                0.9 * scale, 0.8 * scale,
                0.6 * scale, 1.1 * scale,
                0 * scale, 1.1 * scale
            );
            shape.bezierCurveTo(
                -0.6 * scale, 1.1 * scale,
                -0.7 * scale, 0.9 * scale,
                -0.7 * scale, 0.8 * scale
            );
            shape.lineTo(-0.7 * scale, 0.4 * scale);
            shape.lineTo(-1 * scale, 0.4 * scale);
            shape.closePath();
            
            // Different depths for each layer
            const depths = [0.4, 0.35, 0.3, 0.25];
            const scales = [1.0, 1.0, 1.0, 1.0];  // Keep same size for all layers
            
            const geometry = new THREE.ExtrudeGeometry(shape, {
                depth: depths[index],
                bevelEnabled: true,
                bevelThickness: 0.05,
                bevelSize: 0.05,
                bevelSegments: 3
            });
            
            geometry.scale(scales[index], scales[index], 1);
            
            return geometry;
        }

        function onMouseMove(event) {
            mouseX = (event.clientX / window.innerWidth) * 2 - 1;
            mouseY = -(event.clientY / window.innerHeight) * 2 + 1;
        }

        function animate() {
            requestAnimationFrame(animate);

            // Smooth mouse following
            targetX += (mouseX - targetX) * 0.05;
            targetY += (mouseY - targetY) * 0.05;

            // Rotate logo group based on mouse with initial tilt
            logoGroup.rotation.x = -0.6 + targetY * 0.3;  // More tilt to show depth
            logoGroup.rotation.y = -0.6 + targetX * 0.5;  // Rotate to show side

            // Individual layer animations
            layers.forEach((layer, index) => {
                // Rotation animation
                layer.rotation.z += (0.005 + index * 0.002) * (index % 2 === 0 ? 1 : -1);
                
                // Floating animation
                layer.position.y = Math.sin(Date.now() * 0.001 + index) * 0.05;
                layer.position.x = Math.cos(Date.now() * 0.0008 + index) * 0.03;
                
                // Scale pulsing
                const scale = 1 + Math.sin(Date.now() * 0.001 + index * 0.5) * 0.03;
                layer.scale.set(scale, scale, 1);
            });

            renderer.render(scene, camera);
        }

        // Initialize 3D logo when page loads
        document.addEventListener('DOMContentLoaded', function() {
            init3DLogo();
        });
    </script>
    
    <!-- Preload avatar assets for smooth transitions -->
    <script src="scripts/preload-avatars.js"></script>
</body>
</html>
